class G2LightBeamTracer : Actor
{
	Vector3 t_pos;
	double t_pitch;
	
	override void BeginPlay()
	{
		t_pos = self.pos;
	}

	override void Tick()
	{
		Super.Tick();
		
		let dX = t_pos.x - self.pos.x;
		let dY = t_pos.y - self.pos.y;
		let dZ = t_pos.z - self.pos.z;
		
		t_pitch = (atan2(sqrt(dX * dX + dY * dY), dZ) * -1) + 90;
		
		PowerFlashlight(master).handPos = t_pos;
		PowerFlashlight(master).beamPitch = t_pitch;
		PowerFlashlight(master).beamAngle = angle;
	}

	Default
	{
	Projectile;
	+MISSILE;
	+NOGRAVITY;
	+NOBLOCKMAP;
	+DONTSPLASH;
	+THRUACTORS;
	Radius 1;
	Height 1;
	Damage 0;
	Speed 65;
	RenderStyle "None";
	}
	
	States
	{
	Spawn:
		TNT1 A 1; //don't need more than a single tick
		Stop;
	}
}

class PowerFlashlight : Powerup
{
    Property EnergyType : energyType;               // Light flickers when player is low on this inventory class
    Property FlickerThreshold : flickerThreshold;   // Threshold amount for light flicker
    Property Offset : ofsX, ofsY, ofsZ;             // Beam offset, relative to attack height

    // Beam hotspot properties
    Property SpotColor : spotColor;
    Property SpotRange : spotRange;                 // Note: I think range depends on beam angle, too
    Property SpotInnerAngle : spotInnerAngle;       // Max brightness inside this angle from center
    Property SpotOuterAngle : spotOuterAngle;       // No light outside this angle

    // Spill light properties
    Property SpillColor : spillColor;
    Property SpillRange : spillRange;
    Property SpillInnerAngle : spillInnerAngle;
    Property SpillOuterAngle : spillOuterAngle;

    // Reflected light properties
    Property BounceColor : bounceColor;
    Property BounceRange : bounceRange;             // Note: Range from point of reflection
    Property BounceInnerAngle : bounceInnerAngle;
    Property BounceOuterAngle : bounceOuterAngle;

    Default
    {
        Inventory.MaxAmount 1;
        Powerup.Duration 0x7FFFFFFF;

        PowerFlashlight.EnergyType "BatteryPower";
        PowerFlashlight.FlickerThreshold 3200;
        PowerFlashlight.Offset 1, 0, 0; // ofsX is 1 so player doesn't illuminate themself

        PowerFlashlight.SpotColor 0xffffff;
        PowerFlashlight.SpotRange 1024;
        PowerFlashlight.SpotInnerAngle 6;
        PowerFlashlight.SpotOuterAngle 8;

        PowerFlashlight.SpillColor 0x888888;
        PowerFlashlight.SpillRange 512;
        PowerFlashlight.SpillInnerAngle 12;
        PowerFlashlight.SpillOuterAngle 15;
    }

    class<Ammo> energyType;
    double flickerThreshold;
    double ofsX, ofsY, ofsZ;

    Color spotColor;
    int spotRange;
    double spotInnerAngle;
    double spotOuterAngle;

    Color spillColor;
    int spillRange;
    double spillInnerAngle;
    double spillOuterAngle;

    Color bounceColor;
    int bounceRange;
    double bounceInnerAngle;
    double bounceOuterAngle;

    FlashlightBeam spot;
    FlashlightBeam spill;

	vector3 handPos;
	double beamAngle, beamPitch;

    override void AttachToOwner(Actor other)
    {
        Super.AttachToOwner(other);

        spot = FlashlightBeam(Spawn("FlashlightBeam", (0,0,0)));
        spot.master = other;
        spot.offset = (ofsX, ofsY, ofsZ);
        spot.args[0] = spotColor.r;
        spot.args[1] = spotColor.g;
        spot.args[2] = spotColor.b;
        spot.args[3] = spotRange;
        spot.spotInnerAngle = spotInnerAngle;
        spot.spotOuterAngle = spotOuterAngle;

        if (spillRange > 0)
        {
            spill = FlashlightBeam(Spawn("FlashlightBeam", (0,0,0)));
            spill.master = other;
            spill.offset = (ofsX, ofsY, ofsZ);
            spill.args[0] = spillColor.r;
            spill.args[1] = spillColor.g;
            spill.args[2] = spillColor.b;
            spill.args[3] = spillRange;
            spill.spotInnerAngle = spillInnerAngle;
            spill.spotOuterAngle = spillOuterAngle;
        }
    }

    override void DoEffect()
    {
        Super.DoEffect();
		
		if(!owner || !owner.player) return;
		
		let batteryPowerLevel = ""..(owner.CountInv(energyType) * 100 / owner.findinventory(energyType).maxamount);
		if(batteryPowerLevel.Length() == 1) batteryPowerLevel = "0"..batteryPowerLevel;
		let FirstChar = batteryPowerLevel.Left(1);
		let SecondChar = batteryPowerLevel.Mid(1,1);
		owner.SetInventory("BatteryDisplay1", FirstChar.toInt());
		owner.SetInventory("BatteryDisplay2", SecondChar.toInt());
		
		Actor beamTracer = owner.SpawnPlayerMissile("G2LightBeamTracer");
		if(beamTracer) beamTracer.master = self;
		
		if(!beamAngle || !beamPitch) return;
		
		let player = owner.player;
		let pmo = player.mo;
		double angle = pmo.angle;
		double pitch = pmo.AimTarget() ? pmo.BulletSlope(null, ALF_PORTALRESTRICT) : pmo.pitch;
		double dist = 5;
		if(abs(pmo.vel.x) > 2 || abs(pmo.vel.y) > 2 || abs(pmo.vel.z) > 2) dist = 15;
		
		let _puff = pmo.LineAttack(angle, dist, pitch, 0, "melee", "GHDummyPuff1", LAF_NOIMPACTDECAL | LAF_NOINTERACT | LAF_NORANDOMPUFFZ);
		spot.beamPos = spill.beamPos = _puff.pos;
		
		if(beamAngle)
		{
			spot.beamAngle = beamAngle;
			spill.beamAngle = beamAngle;
		}
		if(beamPitch)
		{
			spot.beamPitch = beamPitch;
			spill.beamPitch = beamPitch;
		}

        int energy = energyType ? owner.CountInv(energyType) : effectTics;

        int flicker = Random(0, flickerThreshold);
        if (flicker < 0) flicker *= -ticRate;

        if (flicker > energy)
        {
            spot.args[3] = 0;
            if (spill) spill.args[3] = 0;
        }
        else
        {
            spot.args[3] = spotRange;
            if (spill) spill.args[3] = spillRange;
        }
    }

    override void DetachFromOwner()
    {
        spot.Destroy();
        if (spill) spill.Destroy();
        Super.DetachFromOwner();
    }
}

// Spotlight that follows its master around
class FlashlightBeam : SpotLight
{
    Vector3 offset, beamPos;
	Double beamAngle, beamPitch;

    override void Tick()
    {
        Super.Tick();

        let plyr = PlayerPawn(master);
        /*Vector3 beamPos = master.pos;
        beamPos.xy += AngleToVector(master.angle, offset.x);
        beamPos.xy += AngleToVector(master.angle - 90, offset.y);

        let plyr = PlayerPawn(master);
        if (plyr && plyr.player)
        {
            beamPos.z += (plyr.height / 2 + plyr.attackZOffset) * plyr.player.crouchFactor;
        }
        else
        {
            beamPos.z += master.height / 2;
        }*/

        SetOrigin(beamPos, true);

        vel = master.vel;
        //angle = master.angle;
		//pitch = master.pitch;
        angle = beamAngle;
        pitch = beamPitch;
    }
}